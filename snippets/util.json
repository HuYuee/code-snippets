{
	"utils_data_format": {
		"prefix": "$utils_data_format",
		"body": [
			"//格式化日期",
			"Date.prototype.Format = function (fmt) {",
			"    var o = {",
			"        \"y+\": this.getFullYear(),",
			"        \"M+\": this.getMonth() + 1,                 //月份",
			"        \"d+\": this.getDate(),                    //日",
			"        \"h+\": this.getHours(),                   //小时",
			"        \"m+\": this.getMinutes(),                 //分",
			"        \"s+\": this.getSeconds(),                 //秒",
			"        \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度",
			"        \"S+\": this.getMilliseconds()             //毫秒",
			"    };",
			"    for (var k in o) {",
			"        if (new RegExp(\"(\" + k + \")\").test(fmt)){",
			"        if(k == \"y+\"){",
			"            fmt = fmt.replace(RegExp.\\$1, (\"\" + o[k]).substr(4 - RegExp.\\$1.length));",
			"        }",
			"        else if(k==\"S+\"){",
			"            var lens = RegExp.\\$1.length;",
			"            lens = lens==1?3:lens;",
			"            fmt = fmt.replace(RegExp.\\$1, (\"00\" + o[k]).substr((\"\" + o[k]).length - 1,lens));",
			"        }",
			"        else{",
			"            fmt = fmt.replace(RegExp.\\$1, (RegExp.\\$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));",
			"        }",
			"        }",
			"    }",
			"    return fmt;",
			"}",
			"",
			"var date = new Date();",
			"console.log(date.Format(\"yyyy年MM月dd日 hh:mm:ss.S\")); //输出: 2016年04月01日 10:41:08.133",
			"console.log(date.Format(\"yyyy-MM-dd hh:mm:ss\")); //输出: 2016-04-01 10:41:08",
			"console.log(date.Format(\"yy-MM-dd hh:mm:ss\")); //输出: 16-04-01 10:41:08",
			"console.log(date.Format(\"yy-M-d hh:mm:ss\")); //输出: 16-4-1 10:41:08",
			""
		],
		"description": "日期时间格式化"
	},
	"utils_countdown_simple": {
		"prefix": "$utils_countdown_simple",
		"body": [
			"(function() {",
			"    var time = 10;",
			"    var set = setInterval(function() {",
			"        time--;",
			"        console.log(time);",
			"        if(time === 0) {",
			"            clearInterval(set);",
			"        }",
			"    }, 1000);",
			"})()"
		],
		"description": "最简单倒计时"
	},
	"utils_scroll_watch": {
		"prefix": "$utils_scroll_watch",
		"body": [
			"// 滚动监听",
			"window.onscroll=function(){ getScrollTop(); } ",
			"function getScrollTop() { console.log(document.documentElement.scrollTop) }"
		],
		"description": "滚动监听"
	},
	"utils_scrolltop": {
		"prefix": "$utils_scrolltop",
		"body": [
			"/**",
			" * 无动画",
			" * desc 设置滚动条距顶部的距离",
			" */",
			"function setScrollTop(value) {",
			"    window.scrollTo(0, value);",
			"    return value;",
			"}"
		],
		"description": "返回顶部无动画"
	},
	"utils_insertScript": {
		"prefix": "$utils_insertScript",
		"body": [
			"function injectScript(src) {",
			"    var s, t;",
			"    s = document.createElement('script');",
			"    s.type = 'text/javascript';",
			"    s.async = true;",
			"    s.src = src;",
			"    t = document.getElementsByTagName('script')[0];",
			"    t.parentNode.insertBefore(s, t);",
			"}"
		],
		"description": "动态插入script"
	},
	"getCookie": {
		"prefix": "$utils_getCookie",
		"body": [
			"/**",
			" * ",
			" * desc 根据name读取cookie",
			" * param  {String} name ",
			" * return {String}",
			" */",
			"function getCookie(name) {",
			"    var arr = document.cookie.replace(/\\s/g, \"\").split(';');",
			"    for (var i = 0; i < arr.length; i++) {",
			"        var tempArr = arr[i].split('=');",
			"        if (tempArr[0] == name) {",
			"            return decodeURIComponent(tempArr[1]);",
			"        }",
			"    }",
			"    return '';",
			"}"
		],
		"description": "获取cookie"
	},
	"utils_offset": {
		"prefix": "$utils_offset",
		"body": [
			"/**",
			" * ",
			" * desc  获取一个元素的距离文档(document)的位置，类似jQ中的offset()",
			" * param {HTMLElement} ele ",
			" * returns { {left: number, top: number} }",
			" */",
			"function offset(ele) {",
			"    var pos = {",
			"        left: 0,",
			"        top: 0",
			"    };",
			"    while (ele) {",
			"        pos.left += ele.offsetLeft;",
			"        pos.top += ele.offsetTop;",
			"        ele = ele.offsetParent;",
			"    };",
			"    return pos;",
			"}"
		],
		"description": "距离document的位置"
	},
	"utils_pattern_pub/sub": {
		"prefix": "$utils_pattern_pub/sub",
		"body": [
			"/**",
			" * 来自张鑫旭:漫谈js自定义事件、DOM/伪DOM自定义事件",
			" */",
			"var Event = {",
			"    _listeners: {},    ",
			"    // 添加",
			"    addEvent: function(type, fn) {",
			"        if (typeof this._listeners[type] === \"undefined\") {",
			"            this._listeners[type] = [];",
			"        }",
			"        if (typeof fn === \"function\") {",
			"            this._listeners[type].push(fn);",
			"        }    ",
			"        return this;",
			"    },",
			"    // 触发",
			"    fireEvent: function(type) {",
			"        var arrayEvent = this._listeners[type];",
			"        if (arrayEvent instanceof Array) {",
			"            for (var i=0, length=arrayEvent.length; i<length; i+=1) {",
			"                if (typeof arrayEvent[i] === \"function\") {",
			"                    arrayEvent[i]({ type: type });    ",
			"                }",
			"            }",
			"        }    ",
			"        return this;",
			"    },",
			"    // 删除:支持删除指定事件或者所有事件",
			"    removeEvent: function(type, fn) {",
			"        var arrayEvent = this._listeners[type];",
			"        if (typeof type === \"string\" && arrayEvent instanceof Array) {",
			"            if (typeof fn === \"function\") {",
			"                // 清除当前type类型事件下对应fn方法",
			"                for (var i=0, length=arrayEvent.length; i<length; i+=1){",
			"                    if (arrayEvent[i] === fn){",
			"                        this._listeners[type].splice(i, 1);",
			"                        break;",
			"                    }",
			"                }",
			"            } else {",
			"                // 如果仅仅参数type, 或参数fn邪魔外道，则所有type类型事件清除",
			"                delete this._listeners[type];",
			"            }",
			"        }",
			"        return this;",
			"    }",
			"};",
			"",
			"const fn1 = (...args) => {",
			"    console.log('event1 callback !');",
			"}",
			"",
			"const fn2 = (...args) => {",
			"    console.log('event2 callback !');",
			"}",
			"",
			"// \"console\" type bind fn1, fn2",
			"Event.addEvent(\"console\", fn1);",
			"Event.addEvent(\"console\", fn2)",
			"",
			"// delete fn1",
			"// Eventer.removeEvent('console', fn1);",
			"",
			"// delete fn1 & fn2",
			"// Eventer.removeEvent('console');",
			"",
			"// trigger \"console\" type event",
			"Event.fireEvent(\"console\");"
		],
		"description": "观察订阅模式"
	},
	"utils_pattern_single": {
		"prefix": "$utils_pattern_single",
		"body": [
			"var Singleton = {",
			"    name: 'test',",
			"    method: function() {",
			"        console.log(this.name)",
			"    },",
			"    init: function() {",
			"        this.method();",
			"    }",
			"}",
			"Singleton.init();"
		],
		"description": "单体模式"
	},
	"utils_pattern_factory": {
		"prefix": "$utils_pattern_factory",
		"body": [
			"// 工厂模式：封装一类对象，可实例化出一类既可以有共有属性方法，又能有自己独特属性的模式",
			"// 目的:简化创建每一个对象都需要单独new一个，现在工厂模式只需要一个入口即可",
			"// 不是叫学校模式更好吗？学校出来的人各式各样",
			"",
			"// define",
			"function Factory() {",
			"    this.createEmployee = function(type) {",
			"        var employee;",
			"        if ( type === 'fulltime' ) {",
			"            employee = new FullTime();",
			"        }",
			"        else if ( type === 'parttime' ) {",
			"            employee = new PartTime();",
			"        }",
			"        else if ( type === 'temporary' ) {",
			"            employee = new Temporary();",
			"        }",
			"",
			"        employee.type = type;",
			"        employee.say = function() {",
			"            console.log(this.type + \": rate \" + this.hourly + \"/hour\");",
			"        }",
			"",
			"        return employee;",
			"    }",
			"}",
			"var FullTime = function() {",
			"    this.hourly = \"\";",
			"}",
			"var PartTime = function() {",
			"    this.hourly = \"\";",
			"}",
			"var Temporary = function() {",
			"    this.hourly = \"\";",
			"}",
			"",
			"// use",
			"var employees = [];",
			"var factory = new Factory();",
			"employees.push(factory.createEmployee('fulltime'));",
			"employees.push(factory.createEmployee('parttime'));",
			"employees.push(factory.createEmployee('temporary'));",
			"employees.forEach(element => {",
			"    console.log(element);",
			"});"
		],
		"description": "工厂模式"
	},
	"utils_pattern_singleton": {
		"prefix": "$utils_pattern_singleton",
		"body": [
			"// 单例模式：避免一个对象多次创建,与new构建正好相反",
			"",
			"// 定义",
			"Singleton = (function(){",
			"    var instance;",
			"    function createInstance() {",
			"        var object = new Object(\"I am the instance\");",
			"        return object;",
			"    }",
			"    return {",
			"        getInstance: function() {",
			"            if(!instance) {",
			"                instance = createInstance();",
			"            }",
			"            return instance;",
			"        }",
			"    }",
			"})();",
			"",
			"// 使用",
			"var instance1 = Singleton.getInstance();",
			"var instance2 = Singleton.getInstance();",
			"console.log(\"Same instance? \" + (instance1 === instance2)); // true"
		],
		"description": "单例模式"
	},
	"utils_pattern_adapter": {
		"prefix": "$utils_pattern_adapter",
		"body": [
			"// adapter:适配器模式常用作：将一个类的接口转换成客户希望的另外一个接口",
			"// 适配器模式的作用很像一个转接口. 本来iphone的充电器是不能直接插在电脑机箱上的, 而通过一个usb转接口就可以了",
			"// yon的开发其实就是这样：使用yon install命令，但实质是调用npm install进行相关操作",
			"// 所以我们可以称呼适配器为转接头模式",
			"",
			"var $ = function( tag ){",
			"    return document.getElementsByTagName(tag);",
			"}",
			"// 实现$(tag)，其实调用的是getElementsByTagName(tag);"
		],
		"description": "交换头（适配器）模式"
	},
	
	"utils_pattern_Decorator": {
		"prefix": "$utils_pattern_Decorator",
		"body": [
			"// Decorator:装饰器 - 写了四种方法，参见博客",
			"// 使用范围：不影响其本身接口，只是对其进行扩展。",
			"",
			"var Base = function(str) {",
			"    this.name = str;",
			"    this.show = function(){",
			"        return this.name + ' wei'; ",
			"    }",
			"}",
			"",
			"var Person = function(str) {",
			"    Base.apply(this, arguments);",
			"    this.Decorations = {",
			"        show: function() {",
			"            return this.show() + ' dong !';",
			"        }.bind(this)   ",
			"    };",
			"}",
			"",
			"var person = new Person('lee');",
			"console.log(person.show());",
			"console.log(person.Decorations.show());"
		],
		"description": "装饰器：扩展现有接口"
	},
	"utils_pattern_proxy": {
		"prefix": "$utils_pattern_proxy",
		"body": [
			"// 代理模式：主要用于缓存结果，用于项目优化。",
			"// 使用场景：缓存结果避免多次请求，合并请求，图片懒加载",
			"// define",
			"const mult = function() {",
			"    let a = 1;",
			"    for(let i=0; i<arguments.length; i++) {",
			"        a *= arguments[i];",
			"    }",
			"    return a;",
			"};",
			"",
			"const plus = function() {",
			"    let a = 0;",
			"    for(let i=0; i<arguments.length; i++) {",
			"        a += arguments[i];",
			"    }",
			"    return a;",
			"}",
			"",
			"const createProxyFactory = function(fn) {",
			"    let cache = {};",
			"    return function() {",
			"        let args = Array.from(arguments).join(',');",
			"        if (args in cache) {",
			"            console.log('缓存内容已存在');",
			"            return cache[args];",
			"        } else {",
			"            console.log('第一次执行');",
			"            return cache[args] = fn.apply(this, arguments);",
			"        }",
			"    };",
			"}",
			"",
			"// use",
			"const proxyMult = createProxyFactory(mult);",
			"const proxyPlus = createProxyFactory(plus);",
			"console.log(proxyMult(1,2,3,4)); // 24",
			"console.log(proxyPlus(1,2,3,4)); // 10",
			"console.log(proxyMult(1,2,3,4)); // 缓存内容已存在 24"
		],
		"description": "代理(缓存)模式.用于优化"
	},
	"utils_pattern_flyweight": {
		"prefix": "$utils_pattern_flyweight",
		"body": [
			"/**",
			" * Flyweight - 享元模式，用于项目优化：将重复的出现抽取并缓存起来",
			" * 适用于创建大数据量时使用",
			" * 包含了proxy缓存这部分思想",
			" * 这个模式应该字面直接翻译：飞一般清爽",
			" */",
			"// ",
			"// ",
			"",
			"// 以下例子如创建一台iphone",
			"// model,screen,memory的属性就那几个，所以一旦要创建上万个iphone对象，每次都要创建这几个属性开销就太浪费",
			"// 不如将他们组合出现的几种情况，遇到了就保存起来，以后直接拿来用即可",
			"// 而SN码因为每台都不一样，需要单独创建",
			"",
			"// define",
			"function PhoneBaseAttr(model, screen, memory) {",
			"    this.model = model;",
			"    this.screen = screen;",
			"    this.memory = memory;",
			"}",
			"var PhoneFactory = (function(){",
			"    var phone = {};",
			"    return function(model, screen, memory) {",
			"        var key = model + screen + memory;",
			"        if(!phone[key]){",
			"            return phone[key] = new PhoneBaseAttr(model, screen, memory);",
			"        } else {",
			"            console.log('已缓存');",
			"            return phone[key];",
			"        }",
			"    }",
			"})()",
			"function Phone(model, screen, memory, SN) {",
			"    this.base = PhoneFactory(model, screen, memory);",
			"    this.SN = SN;",
			"}",
			"",
			"// use",
			"var phones = [];",
			"for(var i=0; i< 100; i++) {",
			"    var memory = i % 2 == 0 ? 16 : 32;",
			"    phones.push(new Phone(\"iphone6s\", 5.0, memory, i))",
			"}",
			"console.log(phones);"
		],
		"description": "合并重复,非一般清爽"
	},
	"utils_pattern_facade": {
		"prefix": "$utils_pattern_facade",
		"body": [
			"/**",
			" * facade - 面子模式（外套模式），基本不用讲：套个外套，打扮的人模人样的",
			" * 一个方法由多个方法组成，做一个抽象",
			" */",
			"",
			"var stopEvent = function( e ){   //同时阻止事件默认行为和冒泡",
			"    e.stopPropagation();",
			"    e.preventDefault();",
			"}"
		],
		"description": "外套模式,人模狗样"
	},
	"utils_base64": {
		"prefix": "$utils_base64",
		"body": [
			"//  string covert to base64",
			"window.btoa(string)",
			"",
			"//  base64 convert to string",
			"window.atob(string)"
		],
		"description": "base64转换"
	},
	"utils_pattern_chain": {
		"prefix": "$utils_pattern_chain",
		"body": [
			"/**",
			" * 模拟jQuery链式写法:",
			" * 1.实现创建对象隐藏new",
			" * 2.演示如何操作dom",
			" * param {dom} selector ",
			" */",
			"var BB = function(selector, context) {",
			"    return new BB.fn.init(selector, context);",
			"}",
			"BB.fn = {",
			"    init: function(selector, context){",
			"        console.log('init');",
			"        this.doms = document.getElementsByTagName(selector);",
			"        return this;",
			"    },",
			"    toArray: function() {",
			"        console.log('toArray');",
			"        return this;",
			"    },",
			"    showList: function() {",
			"        console.log(this.doms.length);",
			"        return this;",
			"    },",
			"    extend: function(obj){",
			"        // 以下代码未考虑objKey存在以及obj[objKey]不为函数的情况",
			"        for(var key in obj) {",
			"            this[key] = obj[key];",
			"        }",
			"    }   ",
			"}",
			"BB.fn.init.prototype = BB.fn",
			"BB.fn.extend({'myAdd': function(a,b){console.log(a + b); return this}})",
			"BB('span').toArray().showList().myAdd(2,3);",
			""
		],
		"description": "链式写法"
	},
	"utils_json_pretty_tab": {
		"prefix": "$utils_json_pretty_tab",
		"body": [
			"var ${1:Obj} = ${2:{ foo: \"sample\", bar: \"sample\" }};",
			"var ObjStr = JSON.stringify($1, null, 4)",
			"// output",
			"// {",
			"//   \"foo\": \"sample\", ",
			"//   \"bar\": \"sample\" ",
			"// }"
		],
		"description": "json美化形式"
	},
	"utils_add_remove_class": {
		"prefix": "$utils_add_remove_class",
		"body": [
			"document.getElementById(\"div\").classList.add(\"className\");",
			"document.getElementById(\"div\").classList.remove(\"className\");"
		],
		"description": "增加删除类"
	},
	"utils_data_type": {
		"prefix": "$utils_data_type",
		"body": [
			"const toString = Object.prototype.toString;",
			"",
			"toString.call(new Date);    // [object Date]",
			"toString.call(new String);  // [object String]",
			"toString.call(Math);        // [object Math]",
			"toString.call(3);           // [object Number]",
			"toString.call([]);          // [object Array]",
			"toString.call({});          // [object Object]",
			"",
			"// Since JavaScript 1.8.5",
			"toString.call(undefined);   // [object Undefined]",
			"toString.call(null);        // [object Null]",
			"",
			"toString.call(new Map); // [object Map]",
			"toString.call(new Set); // [object Set]"
		],
		"description": "判断数据类型"
	}
}